## 漫画算法-小灰的算法之旅（16）

[TOC]

### 1. 什么是计数时间排序

**计数排序**：利用数组下标来确定元素的正确位置的算法，时间复杂度为线性时间、

#### 初识计数排序

假设数组中有20个随机整数，取值范围为(0~10),要求用最快的速度把这个20个整数从小到大进行排序。

如何给这些无序的随机整数进行排序呢？

考虑到这些整数只能在(0,1,2,3,4,5,6,7,8,9,10)这11个数中取值，取值范围有限。所以，可以根据这个有限的范围，建立一个长度为11的数组，数组下标从0到10，元素初始值全部为0.



假设20个随机整数的值如下所示:{9,3,5,4,9,1,2,7,8,1,3,6,5,3,4,0,10,9,7,9};下面就开始遍历这个无序的随机数列，每一个整数按照其值对号入座，同时，对应数组下标的元素进行加1操作。

例如第一个整数是9，那么数组下标为9的元素加1。



第二个整数是3，那么数组下标为3的元素加1.



继续遍历数列并修改数组.....

最终，当数列遍历完毕时，数组的状态如下图。



该数组中每一个下标位置的值代表数列中对应整数出现的次数。有了这个统计结果，排序就很简单了，直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次。

{0,1,1,2,3,3,3,4,4,5,5,6,7,7,8,9,9,9,9,10}

显然，现在输出的数列已经是有序的了。

**计数排序**：适用于一定范围内的整数排序，在取值范围不是很大的情况下，它的性能甚至快过哪些时间复杂度为O(n*logn)的排序算法。

#### 代码实现

```java

public static int[] countSort(int[] array){
  
  //1. 得到数列的最大值
  int max =array[0];
  for(int i=1;i<array.length;i++){
    if(array[i]>max){
      max=array[i];
    }
  }
  //2. 根据数列最大值确定统计数组的长度
  int[] countArray =new int[max+1];
  // 3.遍历数列，填充统计数组
  for(int i=0;i<array.length;i++){
    countArray[array[i]]++;
  }
  // 4.遍历统计数组，输出结果
  int index=0;
  int[] sortedArray=new int[array.length];
  for(int i=0;i<countArray.length;i++){
    for(int j=0;j<countArray[i];j++){
      sortedArray[index++]=i;
    }
  }
  return sortedArray;
}

public static void main(String[] args){
  int[] array=new int[]{4,4,6,5,3,2,8,1,7,5,6,0,10};
  int[] sortedArray=countSort(array);
  System.out.println(Arrays.toString(sortedArray));
}
```

这段代码在开头有一个步骤，就是求数列的最大整数值max。后面创建的统计数组countArray，长度是max+1,以此来保证数组的最后一个下标是max。

#### 计数排序的优化

上边的代码存在一个缺陷，那就是存在空间浪费的问题。比如一组数据{95,94,91,98,99,90,99,93,91,92},其中最大值为99，按照上边的思路，我们需要创建一个长度为100的计数数组，但我们可以发现，它前面的[0,89]的空间是完全浪费了的，那么该如何优化呢？

将数组长度定为(max-min+1),即不经要找出最大值，还要找出最小值，**根据两者的差值来确定计数数组的长度**。

同时，数列的最小值作为一个偏移量，用于计算整数在统计数组中的下标。

以刚才的数列为例，统计出数组的长度为(99-90+1)=10；偏移量等于数列中的最小值90.

对于第一个整数95，对应的统计数组下标为(95-90)=5;如下图所示：



如此变实现了对计数排序进行优化，但其实计数排序，并没有真正地对原始数列进行排序。因此在现实业务中，如果要给学生的考试分数进行排序，对于相同分数的学生，应该如何排序呢？



给出一个学生成绩表，要求按照**成绩从低到高进行排序**，如果成绩相同，则遵循原固有顺序。那么，当我们填充统计数组以后，只知道有两个成绩并为95分的同学，并不知道哪一个是小红，哪一个是小绿。那么该如何解决这个问题呢？



仍然以刚才的学生成绩表为例，将之前的统计数组变成下面的样子。



这是如何变形的呢？ 其实**就是从统计数组的第二个元素开始，每一个元素都加上前面所有元素之和。**

为什么要想加呢？ 目的是为了让统计数组存储的元素值，等于相应整数的最终排序位置的序号。例如下标是9的元素值为5，代表原始数列的整数9，最终的排序在第5位。

接下来，创建输出数组sortedArray,长度和输入数列一致。然后从后向钱遍历输入数列。

第一步，遍历成绩表最后一行的小绿同学的成绩。

小绿的成绩是95分，找到countArray下标是5的元素，值是4，代表小绿的成绩排名位置在第4位。同时，给countArray下标是5的元素值减1，从4变成3，代表下次在遇到95分的成绩时，最终排名是第3.



第二步，遍历成绩表倒数第2行的小白同学的成绩。

小白的成绩是94分，找到countArray下标是4的元素，值是2，代表小白的成绩排名位置在第2位。同时，给countArray下标是4的元素值减1，从2变成1，代表下次再遇到94分的成绩时(实际上已经遇不到了)，最终排名是第1.



第三步，遍历成绩表倒数第3行的小红同学的成绩。

小红同学的成绩是95分，找到countArray下标是5的元素，值是3(最初是4，减1变成了3)，代表小红的成绩排名位置在第3位。同时，给countArray下标是5的元素值减1，从3变成2，代表下次再遇到95分的成绩时（实际上已经遇不到了）,最终排名是第2.

这样一来，同样是95分的小红和小绿就能够清楚地排出顺序了，也正因为此，优化版本的计数排序属于**稳定排序**。

#### 代码实现

```java

public static int[] countSort(int[] array){
  
  //1. 得到数列的最大值和最小值，并算出差值d
  
  int max=array[0];
  int min=array[0];
  for(int i=1;i<array.length;i++){
    if(array[i]>max){
      max=array[i];
    }
    if(array[i]<min){
      min=array[i];
    }
  }
  //
  int d =max-min;
  //2.创建统计数组并统计对应元素的个数
  int[] countArray=new int[d+1];
  for(int i=0;i<array.length;i++){
    countArray[array[i]-min]++;
  }
  //3. 统计数组做变形，后面的元素等于前面的元素之和
  for(int i=1;i<countArray.length;i++){
    countArray[i]+=countArray[i-1];
  }
  //4. 倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组
  int[] sortedArray =new int[array.length];
  for(int i=array.length-1;i>=0;i--){
    sortedArray[countArray[array[i]-min]-1]=array[i];
    countArray[array[i]-min]--;
  }
  return sortArray;
}

public static void main(String[] args){
  
  int[] array=new int[]{95,94,91,98,99,90,99,93,91,92};
  int[] sortedArray=countArray(array);
  System.out.println(Arrays.toString(sortedArray));
}
```



#### 时间复杂度

代码中第1，2，4步都设计到遍历原始数列，运算量都是n,第3步遍历统计数列，运算量是m.因此总运算量是3n+m;时间复杂度是O(n+m)

**空间复杂度**：如果步考虑结果数组，只需要统计数组大小的话，空间复杂度为O(m).



## 2. 总结



* 当数列最大和最小值差距过大时，并不适合采用计数排序
  * 例如给出20个随机数，范围在0～1亿之间，如果此时采用计数排序，需要创建长度为1亿度数组，不但严重浪费空间，而且时间复杂度也会随之升高。

* 当数列元素不是整数时，也不适合用计数排序
  * 如果数列中的元素都是小树，则无法创建对应的统计数组。这样显然无法进行计数排序。


