## 漫画算法-小灰的算法之旅（27）

[TOC]

### 1. 如何求解金矿问题

>Q: 有一位国王拥有5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人人数也不同。例如：
>
>有的金矿储量是400kg黄金，需要5个工人来挖掘；
>有的金矿储量是500kg黄金，需要5个工人来挖掘；
>有的金矿储量是200kg黄金，需要2个工人来挖掘；
>有的金矿储量是300kg黄金，需要4个工人来挖掘；
>有的金矿储量是350kg黄金，需要3个工人来挖掘；
>
>如果参与挖矿的工人总数是10人，每座金矿要么全挖，要不不挖，不能派一半人挖取一半的金矿。要求用程序求出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？

#### 动态规划解答

>所谓动态规划：就是把复杂的问题简化成规模较小的子问题，再从简单的子问题自底向上一步一步递推，最终得到复杂问题的最优解。

对于问题中的金矿来说，每一个金矿都存在着"挖"和“不挖”两种选择。

假设，最后一个金矿注定不被挖掘，那么问题就转化成，求10个工人在前4个金矿中做出最优选择。



相应的，假设最后一个金矿一定会被挖掘，那么问题又转化成，求7个人在前4个金矿中做出最优选择(最后一个金矿消耗3个工人)。



形如这两种简化情况，被称为全局问题的两个**最优子结构**。那么，究竟哪一种最优子结构可以通向全局最优解呢？

那就要看**10个工人在前4个金矿的收益 和（7个工人在前4个金矿的收益+最后一个金矿的收益）**谁收益更大了。



同样的道理，对于前4个金矿的选择，我们还可以做进一步简化。

首先针对**10个工人在前4个金矿的收益**这个子结构中，第4个金矿(300kg黄金/4人)可以选择挖与不挖。根据第4个金矿的选择，问题又化简为两种更小的子结构。

* 10个工人在前3个金矿中做出最优选择。
* 6（10-4=6）个工人在前3个金矿中做出最优选择。

相应的，对于**7个工人4个金矿的收益**子结构中，第4个金矿同样可以选择挖和不挖。根据第4个金矿的选择，问题也被简化成两种更小的子结构：

* 7个工人在前3个金矿中做出最优选择。
* 3（7-4=3）个工人在前3个金矿中做出最优选择。

如此不断分解问题，一分为二，二分为四，一直到把问题分解成0个金矿或0个工人时的最优选择，此时的收益结果必然为0，由此我们也就推断出了问题的**边界**。

由此便引出了动态规划的核心要点：**确定全局最优解和最优子结构之间的关系，以及问题的边界。用数学公式来表达的话，即状态转移方程式**

回到例子：

我们把金矿数量设为n;
工人数量设为w;
金矿的含金量设为数组g[]；
金矿锁需开采人数设为数组p[];
设F(n,w) 为n个金矿、w 个工人时的最优收益函数；
则推出状态转移方程式为：

**问题边界**：金矿数为0或工人数为0的情况。 F(n,w)=0 (n=0,w=0)

**当所剩工人不够挖掘当前金矿时**：只有一种最优子结构。 F(n,w)=F(n-1,w) (n>=1, w<p[n-1])

**常规情况**：具有两种最优子结构(挖当前金矿或不挖当前金矿)。F(n,w)=max( F(n-1,w), F(n-1,w-p[n-1]) + g[n-1] ) ( n>=1, w>= p[n-1] )

#### 递归实现

```java
/**
* 获得金矿最优收益
* param w 工人数量
* param n 可选金矿数量
* param p 金矿开采所需的工人数量
* param g 金矿储量
*/
public static int getBestGoldMining(int w,int n,int[] p,int[] g){
  if(w==0 || n==0){
    return 0;
  }
  if(w<p[n-1]){
    return getBestGoldMining(w,n-1,p,g);
  }
  return Math.max(getBestGoldMining(w,n-1,p,g) ,
                 getBestGoldMining(w-p[n-1], n-1 , p ,g ) +g[n-1] );
}

public static void main(String[] args){
  int w=10;
  int[] p ={5,5,3,4,3};
  int[] g={400,500,200,300,350};
  System.out.println("最优收益："+getBestGoldMining(w,g.length,p,g) );
  
}
```

#### 时间复杂度

由于采用递归实现，全局问题经过简化，会拆解成两个字结构；两个子结构会再次简化，会被拆解成4个更小的子结构... 直到被分解为问题边界为止。 如果金矿数量为n，工人数量充足，那么时间复杂度为O(2^n)。

#### 问题优化

我们可以借助画递归树来辅助分析递归调用存在的缺点。我们可以发现递归方法树中的方法存在被重复调用的情况。那么如何避免重复调用的问题呢？

这也就引出了**动态规划**的另一个核心要点：**自底向上求解（自顶向下求解）**

**引出DP(Dynamic Programming) table辅助计算**

在进行求解之前，先准备一张表格，用于记录选择金矿的中间数据。

设表格最左侧代表不同的金矿选择范围，从上到下，每多增加一行，就代表多了一个金矿可选择项，即 F(n,w) 函数中的n值。

表格的最上方代表工人数量，从1个工人到10个工人，即F(n,w)函数中的w值。

其余空白的格子都是等待记录的，代表当**给出n个金矿、w个工人时的最优收益**，即 F(n,w)函数的值





下面让我们从第1行1列开始，尝试把空白的格子一一填满，填充的依据就是**状态转移方程式**。

对于第一行的前4个格子，满足**当所剩工人不够挖掘当前金矿时**：只有一种最优子结构。 F(n,w)=F(n-1,w) (n>=1, w<p[n-1])

因此带入**状态转移方程式**求解：
F(1,1)=F(1-1,1)=F(0,1)=0
F(1,2)=F(1-1,2)=F(0,2)=0
F(1,3)=F(1-1,3)=F(0,3)=0
F(1,4)=F(1-1,4)=F(0,4)=0



第一行的后面6个格子，满足**常规情况**：具有两种最优子结构(挖当前金矿或不挖当前金矿)。F(n,w)=max( F(n-1,w), F(n-1,w-p[n-1]) + g[n-1] ) ( n>=1, w>= p[n-1] )

因此带入**状态转移方程式**求解：

F(1,5)=max( F(1-1,5) ,F(1-1,5-5) +400) =max( F(0,5), F(0,0) +400 ) =max( 0, 400 )=400
F(1,6)=max( F(1-1,6) ,F(1-1,6-5) +400) =max( F(0,6), F(0,1) +400 ) =max( 0, 400 )=400
F(1,7)=max( F(1-1,7) ,F(1-1,7-5) +400) =max( F(0,7), F(0,2) +400 ) =max( 0, 400 )=400
F(1,8)=max( F(1-1,8) ,F(1-1,8-5) +400) =max( F(0,8), F(0,3) +400 ) =max( 0, 400 )=400
F(1,9)=max( F(1-1,9) ,F(1-1,9-5) +400) =max( F(0,9), F(0,4) +400 ) =max( 0, 400 )=400
F(1,10)=max( F(1-1,10) ,F(1-1,10-5) +400) =max( F(0,10), F(0,5) +400 ) =max( 0, 400 )=400



对于第2行的前4个格子，和第1行同理，满足**当所剩工人不够挖掘当前金矿时**：只有一种最优子结构。 F(n,w)=F(n-1,w) (n>=1, w<p[n-1])

因此带入**状态转移方程式**求解：
F(2,1)=F(2-1,1)=F(1,1)=0
F(2,2)=F(2-1,2)=F(1,2)=0
F(2,3)=F(2-1,3)=F(1,3)=0
F(2,4)=F(2-1,4)=F(1,4)=0



第2行的后面6个格子，满足**常规情况**：具有两种最优子结构(挖当前金矿或不挖当前金矿)。F(n,w)=max( F(n-1,w), F(n-1,w-p[n-1]) + g[n-1] ) ( n>=1, w>= p[n-1] )

因此带入**状态转移方程式**求解：

F(2,5)=max( F(2-1,5) ,F(2-1,5-5) +500) =max( F(1,5), F(1,0) +500 ) =max( 400, 500 )=500
F(2,6)=max( F(2-1,6) ,F(2-1,6-5) +500) =max( F(1,6), F(1,1) +500 ) =max( 400, 500 )=500
F(2,7)=max( F(2-1,7) ,F(2-1,7-5) +500) =max( F(1,7), F(1,2) +500 ) =max( 400, 500 )=500
F(2,8)=max( F(2-1,8) ,F(2-1,8-5) +500) =max( F(1,8), F(1,3) +500 ) =max( 400, 500 )=500
F(2,9)=max( F(2-1,9) ,F(2-1,9-5) +500) =max( F(1,9), F(1,4) +500 ) =max( 400, 500 )=500
F(2,10)=max( F(2-1,10) ,F(2-1,10-5) +500) =max( F(1,10), F(1,5) +400 ) =max( 400, 400+500 )=900



同理，第3行的计算方式如下图：



第4行的计算结果如下图：



第5行的计算结果如下图：



最终，最后1行最后1格子所填的900便是最终的最优收益值。即5个金矿、10个工人的最优收益为900kg黄金。



#### 代码实现(二维数组表实现)

```java

/**
* 获得金矿最优收益
* param w 工人数量
* param p 金矿开采所需的工人数量
* param g 金矿存储量
*/
public static int getBestGoldMiningV2(int w,int[] p,int[] g){
  //创建dp table
  int[][] DPtable=new int[g.length+1][w+1];
  // 填充table
  for(int i=1;i<=g.length;i++){
    for(int j=1;j<=w;j++){
      if(j<p[i-1]){
        DPtable[i][j]=DPtable[i-1][j];
      }else{
        DPtable[i][j]=Math.max(DPtable[i-1][j], DPtable[i-1][j-p[i-1]] +g[i-1]);
      }
    }
  }
  // 返回最后一个格子的值
  return DPtable[g.length][w];
}
```

#### 时间复杂度

代码使用双循环来填充DPtable ,所以时间复杂度和空间复杂度都是O(nw)。






#### Reference

>https://zhuanlan.zhihu.com/p/78220312




