## 极客-算法学习笔记(06)

[TOC]

### 删除有序数组中的重复项

>给定一个有序数组nums,请你原地删除重复出现的元素，使得每个元素值出现一次，返回删除后的数组的新长度。
>
>不要使用额外的数组空间，你必须在原地修改输入数组，并在使用O(1)额外空间的条件下完成
>
>说明：
>
>为什么返回数值是整数，但输出的答案是数组呢？
>
>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的
>
>Eg:
>
>输入：nums=[1,1,2]
>
>输出：2，nums=[1,2]
>
>解释：函数应该返回新的长度2，并且原数组nums的前两个元素被修改为1，2，不需要考虑数组中超出新长度后面的元素。
>
>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

#### 思路

本题采用双指针法求解。定义两个指针slow、fast，初始时，定义slow从数组下标0开始，fast从数组下标1开始，当两个指针对应的元素值相等时，快指针fast加1，继续执行循环，当两个指针对应的元素值不相等时，将慢指针slow加1，并将快指针对应的元素值赋值给slow指针对应的元素，然后fast指针继续后移，依次下去，直到循环结束。

#### 复杂度分析

* 时间复杂度： O(n), 需要循环n次
* 空间复杂度：O(1)

#### 代码实现

```go
// 删除有序数组中的重复项
func removeDuplicates(nums []int) int {
	if len(nums)<=1 {
    return len(nums)
	}
	slow :=0
	for fast:=1;fast< len(nums);fast++ {
		if nums[fast]!=nums[slow] {
			slow++
			nums[slow]=nums[fast]
		}
	}
	return slow+1
}
```

### 旋转数组

>给定一个数组，将数组中的元素向右移动`k`个位置，其中`k`是非负数
>
>进阶：
>
>* 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题
>* 你可以使用空间复杂度为O(1)的原地算法解决这个问题吗？
>
>Eg:
>
>输入：nums=[1,2,3,4,5,6,7] ,k=3
>
>输出：[5,6,7,1,2,3,4]
>
>解析：
>
>向右旋转一步：[7,1,2,3,4,5,6]
>
>向右旋转两步：[6,7,1,2,3,4,5]
>
>向右旋转三步：[5,6,7,1,2,3,4]
>
>Eg:
>
>输入：nums=[-1,-100,3,99]，k=2
>
>输出：[3,99,-1,-100]
>
>解释：
>
>向右旋转1步：[99,-1,-100,3
>
>向右旋转2步：[3,99,-1,-100]
>
>链接：https://leetcode-cn.com/problems/rotate-array/

#### 解法1: 使用额外数组

**思路**

我们可以使用额外的数组来将每个元素放至正确的位置。用n表示数组的长度，我们遍历原数组，将原数组下标为i的元素放至新数组下标为`(i+k) mod n`的位置，最后将新数组拷贝至原数组即可

**复杂度分析**

* 时间复杂度：O(n) 其中n为数组长度
* 空间复杂度：O(n), 创建了额外的数组空间

**代码实现**

```go
// 旋转数组
func rotate(nums []int, k int)  {
	// 创建一个空数组
	temp :=make([]int,len(nums))
	//遍历原数组， 将原数组下标为 ii 的元素放至新数组下标为 (i+k)mod n的位置
	for i :=0;i<len(nums);i++{
		temp[(i+k)%len(nums)]=nums[i]
	}
	// 将temp数组copy到原数组
	copy(nums,temp)
}
```

#### 解法2：数组翻转

**思路**

该方法基于如下的事实：当我们将数组的元素向右移动k次后，尾部`k mod n`个元素会移动至数组头部，其余元素向后移动`k mod n `个位置 。该方法为数组的翻转：我们呢可以先将所有元素翻转，这样尾部的`k mod n`个元素就被移动到数组头部，然后再翻转[0,k mod n-1]区间的元素和[k mod n,n-1]区间的元素即可。示例：



| 操作                             | 结果          |
| -------------------------------- | ------------- |
| 原始数组                         | 1,2,3,4,5,6,7 |
| 翻转所有元素                     | 7,6,5,4,3,2,1 |
| 翻转[0, (k mod (n-1))]区间的元素 | 5,6,7,4,3,2,1 |
| 翻转[(k mod n),n-1]区间的元素    | 5,6,7,1,2,3,4 |

**复杂度分析**

* 时间复杂度：O(n)，其中 n 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O(2n)=O(n)。
* 空间复杂度：O(1)

**代码实现**

```go
// 翻转数组
func rotateV2(nums []int,k int)  {
	k = len(nums)%k
	// 1.先对整个数组实行翻转，这样原数组中需要翻转的子数组，就会跑到数组最前端
	reverse(nums)
	// 2.以k为分界线，将做翻转后的数组分割为左右两个数组，先翻转[0,k]的数组，
	reverse(nums[:k])
	// 3.翻转[k:n]的数组
	reverse(nums[k:])
}
func reverse(a []int)  {
	for i,n :=0,len(a);i<n/2;i++ {
		a[i],a[n-i-1]=a[n-1-i],a[i]
	}
}
```

#### 解法3: 环状替换

**思路**

创建一个temp变量，将被替换的元素保存到temp中，从位置0开始，最终令`temp=nums[0]`。根据规则，位置0的元素会放至`(0+k) mod n`的位置，令`x=(0+k) mod n`,此时交换`temp`和`nums[x]`,完成位置x的更新。然后，我们考察位置x,并交换`temp`和`nums[(x+k)mod n]`,从而完成下一个位置的更新。不断进行上诉操作，知道回到初识位置0.

很容易发现，当回到初始位置0时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从0开始不断遍历，最终回到起点的过程中，我们呢遍历了多少个元素？

由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为a圈；再设该过程总共遍历了b个元素。因此，我们有`an=bk`,即`an`一定为`n,k`的公倍数。又因为我们呢在第一次回到起点时就结束，因此a要尽可能小，故an就是n,k的最小公倍数`lcm(n,k)`,因此b 就为`lcm(n,k)/k`。

这说明单次遍历会访问到`lcm(n,k)/k`个元素。为了访问到所有的元素，我们需要进行遍历的次数为:

n /(lcm(*n*,*k*)/*k)  = n*k /(lcm(*n*,*k*))=gcd(*n*,*k*)

其中gcd指的是最大公约数。

如果读者对上面的数学推导的理解有一定困难，也可以使用另外一种方式完成代码：使用单独的变量 count 跟踪当前已经访问的元素数量，当`count=n` 时，结束遍历过程

**复杂度分析**

- 时间复杂度：O*(*n*)，其中 n*n* 为数组的长度。每个元素只会被遍历一次。
- 空间复杂度：O(1)。我们只需常数空间存放若干变量。

**代码实现**

```go
func rotate(nums []int, k int) {
    n := len(nums)
    k %= n
    for start, count := 0, gcd(k, n); start < count; start++ {
        pre, cur := nums[start], start
        for ok := true; ok; ok = cur != start {
            next := (cur + k) % n
            nums[next], pre, cur = pre, nums[next], next
        }
    }
}

func gcd(a, b int) int {
    for a != 0 {
        a, b = b%a, a
    }
    return b
}
```


