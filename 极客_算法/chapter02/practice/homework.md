## 极客-算法学习笔记(06)

[TOC]

### 删除有序数组中的重复项

>给定一个有序数组nums,请你原地删除重复出现的元素，使得每个元素值出现一次，返回删除后的数组的新长度。
>
>不要使用额外的数组空间，你必须在原地修改输入数组，并在使用O(1)额外空间的条件下完成
>
>说明：
>
>为什么返回数值是整数，但输出的答案是数组呢？
>
>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的
>
>Eg:
>
>输入：nums=[1,1,2]
>
>输出：2，nums=[1,2]
>
>解释：函数应该返回新的长度2，并且原数组nums的前两个元素被修改为1，2，不需要考虑数组中超出新长度后面的元素。
>
>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

#### 思路

本题采用双指针法求解。定义两个指针slow、fast，初始时，定义slow从数组下标0开始，fast从数组下标1开始，当两个指针对应的元素值相等时，快指针fast加1，继续执行循环，当两个指针对应的元素值不相等时，将慢指针slow加1，并将快指针对应的元素值赋值给slow指针对应的元素，然后fast指针继续后移，依次下去，直到循环结束。

#### 复杂度分析

* 时间复杂度： O(n), 需要循环n次
* 空间复杂度：O(1)

#### 代码实现

```go
// 删除有序数组中的重复项
func removeDuplicates(nums []int) int {
	if len(nums)<=1 {
    return len(nums)
	}
	slow :=0
	for fast:=1;fast< len(nums);fast++ {
		if nums[fast]!=nums[slow] {
			slow++
			nums[slow]=nums[fast]
		}
	}
	return slow+1
}
```

### 旋转数组

>给定一个数组，将数组中的元素向右移动`k`个位置，其中`k`是非负数
>
>进阶：
>
>* 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题
>* 你可以使用空间复杂度为O(1)的原地算法解决这个问题吗？
>
>Eg:
>
>输入：nums=[1,2,3,4,5,6,7] ,k=3
>
>输出：[5,6,7,1,2,3,4]
>
>解析：
>
>向右旋转一步：[7,1,2,3,4,5,6]
>
>向右旋转两步：[6,7,1,2,3,4,5]
>
>向右旋转三步：[5,6,7,1,2,3,4]
>
>Eg:
>
>输入：nums=[-1,-100,3,99]，k=2
>
>输出：[3,99,-1,-100]
>
>解释：
>
>向右旋转1步：[99,-1,-100,3
>
>向右旋转2步：[3,99,-1,-100]
>
>链接：https://leetcode-cn.com/problems/rotate-array/

#### 解法1: 使用额外数组

**思路**

我们可以使用额外的数组来将每个元素放至正确的位置。用n表示数组的长度，我们遍历原数组，将原数组下标为i的元素放至新数组下标为`(i+k) mod n`的位置，最后将新数组拷贝至原数组即可

**复杂度分析**

* 时间复杂度：O(n) 其中n为数组长度
* 空间复杂度：O(n), 创建了额外的数组空间

**代码实现**

```go
// 旋转数组
func rotate(nums []int, k int)  {
	// 创建一个空数组
	temp :=make([]int,len(nums))
	//遍历原数组， 将原数组下标为 ii 的元素放至新数组下标为 (i+k)mod n的位置
	for i :=0;i<len(nums);i++{
		temp[(i+k)%len(nums)]=nums[i]
	}
	// 将temp数组copy到原数组
	copy(nums,temp)
}
```

#### 解法2：数组翻转

**思路**

该方法基于如下的事实：当我们将数组的元素向右移动k次后，尾部`k mod n`个元素会移动至数组头部，其余元素向后移动`k mod n `个位置 。该方法为数组的翻转：我们呢可以先将所有元素翻转，这样尾部的`k mod n`个元素就被移动到数组头部，然后再翻转[0,k mod n-1]区间的元素和[k mod n,n-1]区间的元素即可。示例：



| 操作                             | 结果          |
| -------------------------------- | ------------- |
| 原始数组                         | 1,2,3,4,5,6,7 |
| 翻转所有元素                     | 7,6,5,4,3,2,1 |
| 翻转[0, (k mod (n-1))]区间的元素 | 5,6,7,4,3,2,1 |
| 翻转[(k mod n),n-1]区间的元素    | 5,6,7,1,2,3,4 |

**复杂度分析**

* 时间复杂度：O(n)，其中 n 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O(2n)=O(n)。
* 空间复杂度：O(1)

**代码实现**

```go
// 翻转数组
func rotateV2(nums []int,k int)  {
	k = len(nums)%k
	// 1.先对整个数组实行翻转，这样原数组中需要翻转的子数组，就会跑到数组最前端
	reverse(nums)
	// 2.以k为分界线，将做翻转后的数组分割为左右两个数组，先翻转[0,k]的数组，
	reverse(nums[:k])
	// 3.翻转[k:n]的数组
	reverse(nums[k:])
}
func reverse(a []int)  {
	for i,n :=0,len(a);i<n/2;i++ {
		a[i],a[n-i-1]=a[n-1-i],a[i]
	}
}
```

#### 解法3: 环状替换

**思路**

创建一个temp变量，将被替换的元素保存到temp中，从位置0开始，最终令`temp=nums[0]`。根据规则，位置0的元素会放至`(0+k) mod n`的位置，令`x=(0+k) mod n`,此时交换`temp`和`nums[x]`,完成位置x的更新。然后，我们考察位置x,并交换`temp`和`nums[(x+k)mod n]`,从而完成下一个位置的更新。不断进行上诉操作，知道回到初识位置0.

很容易发现，当回到初始位置0时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从0开始不断遍历，最终回到起点的过程中，我们呢遍历了多少个元素？

由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为a圈；再设该过程总共遍历了b个元素。因此，我们有`an=bk`,即`an`一定为`n,k`的公倍数。又因为我们呢在第一次回到起点时就结束，因此a要尽可能小，故an就是n,k的最小公倍数`lcm(n,k)`,因此b 就为`lcm(n,k)/k`。

这说明单次遍历会访问到`lcm(n,k)/k`个元素。为了访问到所有的元素，我们需要进行遍历的次数为:

n /(lcm(*n*,*k*)/*k)  = n*k /(lcm(*n*,*k*))=gcd(*n*,*k*)

其中gcd指的是最大公约数。

如果读者对上面的数学推导的理解有一定困难，也可以使用另外一种方式完成代码：使用单独的变量 count 跟踪当前已经访问的元素数量，当`count=n` 时，结束遍历过程

**复杂度分析**

- 时间复杂度：O*(*n*)，其中 n*n* 为数组的长度。每个元素只会被遍历一次。
- 空间复杂度：O(1)。我们只需常数空间存放若干变量。

**代码实现**

```go
func rotate(nums []int, k int) {
    n := len(nums)
    k %= n
    for start, count := 0, gcd(k, n); start < count; start++ {
        pre, cur := nums[start], start
        for ok := true; ok; ok = cur != start {
            next := (cur + k) % n
            nums[next], pre, cur = pre, nums[next], next
        }
    }
}

func gcd(a, b int) int {
    for a != 0 {
        a, b = b%a, a
    }
    return b
}
```

### 合并两个有序链表

>将两个升序链表合并为一个新的升序链表并返回。新链表时通过拼接给定的两个链表的所有节点组成的。
>
>Eg:
>
>输入： a=[1,2,4] ,b=[1,3,4]
>
>输出：[1,1,2,3,4,4]
>
>链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/

#### 思路

使用迭代暴力求解。当`l1`和`l2`都不是空链表时，判断`l1`和`l2`哪个链表的头节点值更小，将较小值的节点添加到结果链表中，当一个节点被添加到结果里之后，将对应链表中的节点向后移动一位。

首先，定义一个哨兵节点`prehead`,这可以在最后让我们比较容易的返回合并后的链表。我们维护一个`prev`指针，我们需要做的是调整它的`next`指针。然后，我们重复以下过程，直到`l1`或`l2`指向了`null`;如果`l1`当前节点的值小于等于`l2`,就把`l1`当前的节点接在`prev`节点的后面同时将`l1`指针往后移一位。否则，我们对`l2`做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把`prev`指针向后移动一位。

在循环终止时，`l1`和`l2`至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

#### 复杂度分析

* 时间复杂度：O(n+m), 其中n和m分别为两个链表的长度，因为在每次循环迭代中，只有一个元素被放到空合并链表中，
* 空间复杂度：O(1). 我们只需要常数的空间存放若干变量。

#### 代码实现

```go
// 合并两个有序链表
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {

	dummy :=&ListNode{Val: -1,Next: nil}
	prev :=dummy
	for l1 !=nil && l2!=nil {
		if l1.Val<=l2.Val {
			prev.Next=l1
			l1=l1.Next
		}else {
			prev.Next=l2
			l2=l2.Next
		}
		// prev 指针后移
		prev=prev.Next
	}
	// 合并l1和l2之后，最多只有一个还没有被合并完，我们直接将链表末尾指向未合并的链表即可
	if l1==nil {
		prev.Next=l2
	}else {
		prev.Next=l1
	}
	return dummy.Next
}
```

### 合并两个有序数组

>给定两个有序整数数组nums1和nums2,请你将nums2合并到nums1中，使用nums1成为一个有序数组。初始化nums1和nums2的元素数量分别为m和n。你可以假设nums1的空间大小等于m+n,这样它就有足够的空间保存来自nums2的元素。
>
>Eg:
>
>输入：nums1=[1,2,3,0,0,0] m=3; nums2=[2,5,6] n=3
>
>输出：[1,2,2,3,5,6]
>
>链接：https://leetcode-cn.com/problems/merge-sorted-array/

#### 解法1：直接合并后排序

**思路**

最直观的方法是先将数组nums2放到数组nums1的尾部，然后直接对整个数组进行排序。

**复杂度分析**

* 时间复杂度：O((m+n)log(m+n)) 排序序列长度为m+n,使用快速排序的时间复杂度即可，平均情况为O((m+n)log(m+n))
* 空间复杂度：O(log(m+n)) 排序序列长度为m+n,套用快速排序的空间复杂度即可，平均情况为O(log(m+n))

**代码实现**

```go
// 合并两个有序数组
func merge(nums1 []int,m int,nums2 []int ,n int)  {
	// 将nums2 合并到nums1的尾部
	copy(nums1[m:],nums2)
	// 对num1排序
	sort.Ints(nums1)
}
```

#### 解法2：前双指针求解

**思路**

初始化一个空数组temp，数组容量为nums1和nums2的容量之和。把两个数组看作队列，设置两个指针p1,p2 作为队列的头部指针，每次从两个数组头部取出元素，并比较小的数字放到temp数组中。最后将排序后的数组，拷贝到nums1中。

**复杂度分析**

* 时间复杂度：O(m+n)
* 空间复杂度：O(m+n)

**代码实现**

```go
// 双指针解法，   创建了额外的内存空间
func mergeV2(nums1 []int,m int,nums2 []int ,n int)  {

	//初始化排序数组
	sorted :=make([]int,0,m+n)
	p1,p2 :=0,0
	for  {
		// 如果 nums1 为空，返回nums2
		if p1==m {
			sorted=append(sorted,nums2[p2:]...)
			break
		}
		// 如果nums2为空，返回nums1
		if p2==n {
			sorted=append(sorted,nums1[p1:]...)
			break
		}
		// 如果nums1[i]<nums2[i] 将nums1[i] 放到排序后的数组中
		if nums1[p1]<nums2[p2] {
			sorted=append(sorted,nums1[p1])
			p1++
		}else {
			sorted=append(sorted,nums2[p2])
			p2++
		}
	}
	// 将排序后的数组，复制到原nums1数组中
	copy(nums1,sorted)
}
```

#### 解法3：后双指针法(无序辅助空间)

**思路**

注意两个数组均是有序数组，且nums1的后半部分是空的，因此可以直接覆盖而不会影响结果。定义两个指针p1,p2并让两个指针分别从nums1，nums2数组尾部向前遍历。每次将取出的元素作比较，并将较大值放入到nums1的最后面。

严格来说，在此遍历过程中的任意一个时刻，nums1数组中有m-p1-1个元素被放入了nums1的后半部分，nums2数组中有n-p2-1个元素被放入nums1的后半部，而在指针p1的后面，nums1数组有m+n-p1-1个位置。

由于: m+n-p1-1 >= m-p1-1+n-p2-1.  等价于 p2>=-1

因此，等式永远成立。

**复杂度分析**

* 时间复杂度：O(m+n)
* 空间复杂度：O(1). 没有新增辅助数组空间

**代码实现**

```go
func mergeV3(nums1 []int,m int,nums2 []int ,n int)  {

	// 因为两个数组是有序数组，比较两个数组的尾部元素大小，将尾数大的元素追加到nums1的尾部
	for p1 ,p2 ,tail :=m-1,n-1,m+n-1;p1>=0 ||p2>=0; tail--{
		var curr int
		if p1==-1 {
			curr=nums2[p2]
			p2--
		}else if p2==-1 {
			curr=nums1[p1]
			p1--
			//如果nums1尾部大于nums2尾部，将nums1元素追加到 最后  tail--
		}else if nums1[p1]>nums2[p2] {
			curr=nums1[p1]
			p1--
		}else {
			curr=nums2[p2]
			p2--
		}
		nums1[tail]=curr
	}
}
```


